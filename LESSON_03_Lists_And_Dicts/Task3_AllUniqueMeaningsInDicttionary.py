"""
Напишите программу печати всех уникальных значений в словаре. 
Дан список словарей (пользователь его не вводит): 
[{"V":"S001"}, {"V":"S002"}, {"VI":"S001"}, {"VI":"S005"}, {"VII":"S005"}, {"V":"S009"}, {"VIII:"S007"}]
(Интересно, что каждый словарь состоит из одного элемента)
"""
"""
СЛОВАРИ
1. Определение СЛОВАРЯ имеет следующий синтаксис: 
dictionary = { ключ1:значение1, ключ2:значение2, ....}

2. Создание словаря: 
users = {1: "Tom", 2: "Bob", 3: "Bill"}
emails = {"tom@gmail.com": "Tom", "bob@gmai.com": "Bob", "sam@gmail.com": "Sam"}

Необязательно ключи и значения должны быть однотипными. Они могу представлять разные типы:
objects = {1: "Tom", "2": True, 3: 100.6}

3. Создание пустого словаря: 
objects = {}
objects = dict()

4. Словарь можно создать на основе списка двухэлементных списков: 
users_list = [
    ["+111123455", "Tom"],
    ["+384767557", "Bob"],
    ["+958758767", "Alice"]
]
users_dict = dict(users_list)
print(users_dict)

...и кортежа двухэлементных кортежей: 
users_tuple = (
    ("+111123455", "Tom"),
    ("+384767557", "Bob"),
    ("+958758767", "Alice")
)
users_dict = dict(users_tuple)
print(users_dict)

5. ОБРАЩЕНИЕ К ЭЛЕМЕНТАМ СЛОВАРЯ
Обращение к значениям элементов словаря производится по ключу: 
<имя переменной-словаря>[<ключ>]

Если при установки значения элемента с таким ключом в словаре не окажется, то произойдет его добавление:
users["+4444444"] = "Sam"

Но если мы попробуем получить значение с ключом, которого нет в словаре, то Python сгенерирует ошибку KeyError:
user = users["+4444444"]    # KeyError

Чтобы предупредить эту ситуацию перед обращением к элементу мы можем проверять наличие ключа в словаре 
с помощью выражения ключ in словарь. Если ключ имеется в словаре, то данное выражение возвращает True:

key = "+4444444"
if key in users:
    user = users[key]
    print(user)
else:
    print("Элемент не найден")

Для получения элементов можно использовать метод get, который имеет две формы:

get(key) - возвращает из словаря элемент с ключом key. 
Если элемента с таким ключом нет, то возвращает значение None

get(key, default): возвращает из словаря элемент с ключом key. 
Если элемента с таким ключом нет, то возвращает значение по умолчанию default

users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
 
user1 = users.get("+55555555")
print(user1)    # Alice
user2 = users.get("+33333333", "Unknown user")
print(user2)    # Bob
user3 = users.get("+44444444", "Unknown user")
print(user3)    # Unknown user

6. УДАЛЕНИЕ ЭЛЕМЕНТОВ СЛОВАРЯ
Для удаления элемента по ключу применяется оператор del:
del users["+55555555"]

Если подобного ключа не окажется в словаре, то будет выброшено исключение KeyError. 
Поэтому опять же перед удалением желательно проверять наличие элемента с данным ключом.

key = "+55555555"
if key in users:
    del users[key]
    print(f"Элемент с ключом {key} удален")
else:
    print("Элемент не найден")

Другой способ удаления представляет метод pop(). 
Он имеет две формы:

pop(key) - удаляет элемент по ключу key и возвращает удаленный элемент. 
Если элемент с данным ключом отсутствует, то генерируется исключение KeyError

pop(key, default) - удаляет элемент по ключу key и возвращает удаленный элемент. 
Если элемент с данным ключом отсутствует, то возвращается значение default

Если необходимо удалить все элементы, то в этом случае можно воспользоваться методом clear():
users.clear()

7. КОПИРОВАНИЕ СЛОВАРЕЙ (метод copy())

users = {"+1111111": "Tom", "+3333333": "Bob", "+5555555": "Alice"}
students = users.copy()
print(students)     # {"+1111111": "Tom", "+3333333": "Bob", "+5555555": "Alice"}

8. ОБЪЕДИНЕНИЕ СЛОВАРЕЙ (метод update())

users = {"+1111111": "Tom", "+3333333": "Bob"}
users2 = {"+2222222": "Sam", "+6666666": "Kate"}
users.update(users2)

8. ПЕРЕБОР СЛОВАРЯ ЦИКЛОМ FOR

users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
for key in users:
    print(f"Phone: {key}  User: {users[key]} ")

9. ПЕРЕБОР СЛОВАРЯ ПРИ ПОМОЩИ МЕТОДА ITEMS()

for key, value in users.items():
    print(f"Phone: {key}  User: {value} ")

10. ПЕРЕБОР КЛЮЧЕЙ И ЗНАЧЕНИЙ (методы keys() и values())
for key in users.keys():
    print(key)

for value in users.values():
    print(value)

11. КОМПЛЕКСНЫЕ СЛОВАРИ
Кроме простейших объектов типа чисел и строк словари также могут хранить и более сложные объекты - 
те же списки, кортежи или другие словари:
users = {
    "Tom": {
        "phone": "+971478745",
        "email": "tom12@gmail.com"
    },
    "Bob": {
        "phone": "+876390444",
        "email": "bob@gmail.com",
        "skype": "bob123"
    }
}
Для обращения к элементам вложенного словаря соответственно необходимо использовать два ключа:
old_email = users["Tom"]["email"]
users["Tom"]["email"] = "supertom@gmail.com"
print(users["Tom"])     # { phone": "+971478745", "email": "supertom@gmail.com }

Но если мы попробуем получить значение по ключу, который отсутствует в словаре, Python сгенерирует исключение KeyError:
Чтобы избежать ошибки, можно предварительно проверять наличие ключа в словаре:

key = "skype"
if key in users["Tom"]:
    print(users["Tom"]["skype"])
else:
    print("skype is not found")

"""
dict_list = [{"V":"S001"}, {"V":"S002"}, {"VI":"S001"}, {"VI":"S005"}, {"VII":"S005"}, {"V":"S009"}, {"VIII":"S007"}]
print(dict_list)

res = set()

for elem in dict_list : 
    for key in elem : 
        res.add(elem[key])
print(res)

"""
Решение задачи на семинаре. Comprehensions. 
Comprehensions бывают только 3-х типов: списки, множества, словари. Все. 
Если мы пишем круглые скобки, то структура сформируется, но это будет уже не comprehensions, а generator 
(мы их пока не проходили). 
"""
dict_list = [{"V":"S001"}, {"V":"S002"}, {"VI":"S001"}, {"VI":"S005"}, {"VII":" S005 "}, {" V ":" S009 "}, {" VIII":" S007 "}]
print(dict_list)

for elem in dict_list: 
    print(list(elem.values())[0].strip())

# Воспользуемся comprehensions
print(set(list(elem.values())[0].strip() for elem in dict_list))

