# АНОНИМНЫЕ И ЛАМБДА-ФУНКЦИИ

# Рассмотрим обычную функцию f(x), вычисляющую квадрат числа x
def f(x) : 
    return x*x

print(f"f(5) = 5 x 5 = {f(5)}")
print(f"Функция f(x) имеет тип {type(f)}")
# Функция f(x) имеет тип <class 'function'>

a = f
print(f"Переменная а имеет тип {type(a)}")
# Переменная а имеет тип <class 'function'>
print(f"a(5) = 5 x 5 = {a(5)}")

# По сути, мы переименовали некую область памяти, где содержится код,
# реализующий функцию x*x, а, значит, мы, вероятно, можем передавать эти ссылки 
# в качестве параметров в другие функции!!!
# Давайте создадим небольшой калькулятор: 

def calc1 (a, b) : 
    return a+b

def calc2 (a, b) :
    return a*b

def math (op, a, b) : 
    return op(a, b)

print(f"3 + 5 = {math(calc1, 3, 5)}")
print(f"3 * 5 = {math(calc2, 3, 5)}")

# Python - это скриптовый язык, который позволяет сильно сокращать код за счет компактной записи. 
# И подобные простые функции мы также можем записывать в сокращенной форме. 

# Воспользуемся возможностями лямбда-функции: 

calc1 = lambda a, b : a+b
print(calc1(5, 45))

# Можно и не описывать лямбда-функцию в отдельной строке, а описать ее 
# непосредственно в месте использования: 

print(math(lambda a, b: a+b, 5, 45)) # Здесь мы уже воспользовались анонимной (неименованной) функцией

# ЗАДАЧА: 
# В списке хранятся числа. Нужно выбрать из них только четные и составить список пар: (число, квадрат_этого_числа)
# Пример: 1 2 3 5 8 15 23 38
# Результат: [(2, 4), (8, 64), (38, 1444)]

our_list = [1, 2, 3, 5, 8, 15, 23, 38]
print([(i, i**2) for i in our_list if not i%2])

# Воспользуемся для решения этой задачи полученными знаниями: 

def select (f, col) : 
    return [f(x) for x in col]

def where (f, col) : 
    return [x for x in col if f(x)]

data = [1, 2, 3, 5, 8, 15, 23, 38]
res = select(int, data)
print(res)
res = where(lambda x: x%2 == 0, res)
print(res)
res = select(lambda x: (x, x*x), res)
print(res)

# Познакомимся с функцией map
# Функция map принимает на вход два параметра - функцию, которую мы будем применять к элементам некоторой коллекции, 
# и саму эту коллекцию. 

list_1 = [x for x in range(1, 20)]
print(list_1)
list_1 = list(map(lambda x: x+10, list_1))
print(list_1)

# ЗАДАЧА. 
# С клавиатуры вводится набор чисел, в качестве разделителя используется пробел. 
# Этот набор чисел считывается в виде строки. 
# Как превратить список строк в список чисел? 

# inp_str = input("Введите список чисел через пробел => ").split()
# print(inp_str)
# nums = list(map(lambda x: int(x), inp_str))
# print(nums) 

# Можно то же самое сделать в одну строку: 
# print(list(map(int, input("Введите список чисел через пробел => ").split())))

# Познакомимся с функцией filter
# Функция filter отфильтровывает из списка элементы, удовлетворяющие некоторому условию

data = [15, 65, 9, 36, 175]
print(data)

# Давайте из этого списка выберем все числа, которые оканчиваются на 5

res = list(filter(lambda x : x%10 == 5, data))
print(res)

# Познакомимся с функцией zip
# Функция zip применяется к набору итерируемых объектов и возвращает итератор с кортежами из элементов этих объектов, 
# располагающихся на одинаковых позициях, например: 
# zip([1, 2, 3], ['o', 'l', 'v'], [3, 'д', 't']) => [(1, 'o', 3), (2, 'l', 'д'), (3, 'v', 't')]

# ПРИМЕР: 
users = ["Андрей", "Петр", "Sarah", "Степан", "Дарья"]
ids =[14, 46, 1, 4, 67, 58, 100]
user_ids = list(zip(users, ids))
print(user_ids)

# ВАЖНО: Результирующий итератор будет содержать столько элементов, сколько их в минимальной из 
# переданных на вход функции zip коллекций

# Функция enumerate
# Функция enumerate применяется к итерируемому объекту и возвращает новый итератор, значениями которого 
# являются кортежи из индекса и соответствующего ему элементу исходного объекта

print(list(enumerate(["Казань", "Таганрог", "Орел", "Пенза", "Владимир"])))

# ФАЙЛЫ: 
# Файлы в текстовом формате используются: 
# - для хранения данных
# - для передачи данных в клиент-серверных проектах
# - для хранения конфигов
# - для логирования событий

# ЧТО ТРЕБУЕТСЯ ДЛЯ РАБОТЫ С ФАЙЛОМ: 
# - создать переменную, которая будет использоваться для работы с файловым объектом
# - указать путь к файлу
# - указать, в каком режиме мы будем с ним работать

# РЕЖИМЫ РАБОТЫ С ФАЙЛАМИ: 
# a - открытие для добавления данных: 
#   - позволяет дописывать что-то в существующий файл
#   - при попытке открыть в этом режиме несуществующий файл будет создан новый файл, и запись будет осуществляться в него

# r - открытие файла на чтение: 
#   - позволяет читать данные из файла
#   - если попытаться читать из несуществующего файла, программа выдаст ошибку

# w - открытие файла для записи: 
#   - если файла не существует, он будет создан
#   - если такой файл есть, он будет очищен, и в него будут записываться новые данные

# w+ - открыть файл для записи и читать из него. Если файла не существует, то он будет создан

# r+ - открыть файл на чтение и дописывать в него. Если файла не существует, будет выдана ошибка. 

colors = ["red", 'green', 'blue']
data = open('file1.txt', 'a')
data.writelines(colors)
data.close()

colors = ["red", 'green', 'blue']
data = open('file2.txt', 'a', encoding = 'utf-8')
data.writelines(colors)
data.close()

# Чтобы файл закрывался автоматически, можно использовать конструкцию with: 
with open('file3.txt', 'w') as data : 
    data.write("line1\n")
    data.write("line2\n")

# Попробуем теперь считать строки из созданного таким образом файла: 
path = "file3.txt"
data = open(path, 'r')
for line in data : 
    print(line)
data.close()

# БИБЛИОТЕКИ ДЛЯ РАБОТЫ С ОПЕРАЦИОННОЙ СИСТЕМОЙ
# МОДУЛЬ os
# Модуль os предоставляет множество функций для работы с операционной системой, 
# причем их поведение, как правило, не зависит от конкретной операционной системы, 
# поэтому программы остаются переносимыми. 
# Чтобы работать с функциями данного модуля, необходимо импортировать его в программу: 
# import os

# Познакомимся с базовыми функциями данного модуля: 
# os.chdir(path) - смена текущей директории
# os.chdir('C:/Users/79190/PycharmProjects/GB')

#os.getcwd() - узнать, в какой директории мы находимся
# print(os.getcwd()) => 'C:/Users/79190/PycharmProjects/GB'

# Модуль os.path - это модуль, вложенный в модуль os и реализующий функции работы с путями. 
# os.path.basename(path) - базовое имя пути
# os.path.abspath(path) - нормализованный абсолютный путь

import os
print(os.path.basename('C:/Users/79190/PycharmProjects/GB'))
print(os.path.basename(os.getcwd()))
print(os.path.abspath(os.getcwd()))

# Модуль shutil содержит набор функций высокого уровня для обработки файлов, групп файлов и папок. 
# В частности, доступные здесь функции позволяют копировать, перемещать и удалять файлы и папки. 
# Этот модуль часто используется в совокупности с модулем os

import shutil

# Познакомимся с базовыми функциями этого модуля: 
# shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst
# shutil.copy(src, dst) - копирует содержимое файла src в папку или в файл dst
# shutil.rmtree(path) - удаляет текущую директорию и все ее поддиректории (path должен указывать на директорию, 
# а не на символическую ссылку)





